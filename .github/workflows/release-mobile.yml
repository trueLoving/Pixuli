name: 发布 Pixuli Mobile

on:
  workflow_dispatch:
    inputs:
      platform:
        description: '选择要发布的平台'
        required: true
        type: choice
        options:
          - android
          # - ios
          # - both
        default: android
      version:
        description: '指定版本号（例如：1.0.0）。如果为空，将从 tag 或 package.json 中获取'
        required: false
        type: string
        default: ''
      releaseToGitHub:
        description: '将产物附加到 GitHub Release（仅在 tag 或手动开启时）'
        required: true
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  PNPM_VERSION: 9
  NODE_VERSION: 22
  GRADLE_OPTS: -Dorg.gradle.jvmargs="-Xmx4096m -XX:MaxMetaspaceSize=1024m"

jobs:
  detect:
    name: Detect inputs
    runs-on: ubuntu-latest
    outputs:
      do_android: ${{ steps.set.outputs.do_android }}
      do_ios: ${{ steps.set.outputs.do_ios }}
      is_tag: ${{ steps.set.outputs.is_tag }}
      release_enabled: ${{ steps.set.outputs.release_enabled }}
      version: ${{ steps.set.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve inputs
        id: set
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PLATFORM="${{ github.event.inputs.platform }}"
            RELEASE_INPUT="${{ github.event.inputs.releaseToGitHub }}"
            VERSION_INPUT="${{ github.event.inputs.version }}"
          else
            # tag push 默认 both，发布 release
            PLATFORM="both"
            RELEASE_INPUT="true"
            VERSION_INPUT=""
          fi
          DO_ANDROID=false
          DO_IOS=false
          if [[ "$PLATFORM" == "android" || "$PLATFORM" == "both" ]]; then DO_ANDROID=true; fi
          if [[ "$PLATFORM" == "ios" || "$PLATFORM" == "both" ]]; then DO_IOS=true; fi
          IS_TAG=false
          if [[ "${{ startsWith(github.ref, 'refs/tags/') }}" == "true" ]]; then IS_TAG=true; fi

          # 解析版本号
          VERSION=""
          # 1. 优先使用输入的版本号
          if [[ -n "$VERSION_INPUT" ]]; then
            VERSION="$VERSION_INPUT"
            echo "使用输入的版本号: $VERSION"
          # 2. 如果是 tag，从 tag 名称中提取版本号
          elif [[ "$IS_TAG" == "true" ]]; then
            TAG_NAME="${GITHUB_REF#refs/tags/}"
            # 去掉可能的 'v' 前缀
            VERSION="${TAG_NAME#v}"
            echo "从 tag 提取版本号: $VERSION"
          # 3. 从 package.json 中读取版本号作为后备
          else
            if [[ -f "apps/mobile/package.json" ]]; then
              VERSION=$(node -p "require('./apps/mobile/package.json').version" 2>/dev/null || echo "")
              if [[ -n "$VERSION" ]]; then
                echo "从 package.json 读取版本号: $VERSION"
              fi
            fi
          fi

          # 如果仍然没有版本号，使用默认值
          if [[ -z "$VERSION" ]]; then
            VERSION="1.0.0"
            echo "使用默认版本号: $VERSION"
          fi

          echo "do_android=$DO_ANDROID" >> $GITHUB_OUTPUT
          echo "do_ios=$DO_IOS" >> $GITHUB_OUTPUT
          echo "is_tag=$IS_TAG" >> $GITHUB_OUTPUT
          echo "release_enabled=$RELEASE_INPUT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
  android:
    name: Android build
    needs: detect
    if: needs.detect.outputs.do_android == 'true'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: apps/mobile
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Get pnpm store directory
        shell: bash
        id: pnpm-cache
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: |
            **/node_modules
            apps/mobile/node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-
      - name: Install dependencies (workspace)
        run: pnpm install --frozen-lockfile --prefer-offline
        working-directory: .

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      - name: Cache Expo prebuild
        uses: actions/cache@v4
        with:
          path: apps/mobile/android
          key: ${{ runner.os }}-expo-prebuild-${{ hashFiles('apps/mobile/app.json', 'apps/mobile/package.json', 'apps/mobile/app/_layout.tsx') }}
          restore-keys: |
            ${{ runner.os }}-expo-prebuild-
      - name: Generate Android native project
        run: |
          # 只在 android 目录不存在或配置变化时才执行 prebuild
          if [ ! -d "android" ] || [ ! -f "android/app/build.gradle" ]; then
            npx expo prebuild --platform android --clean
          else
            echo "Android 项目已存在，跳过 prebuild"
          fi
        working-directory: apps/mobile

      - name: Extract version
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.detect.outputs.version }}"
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "版本号: $VERSION"
      - name: Configure APK output filename
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          BUILD_GRADLE="android/app/build.gradle"
          # 检查 build.gradle 是否已包含 applicationVariants 配置
          if grep -q "applicationVariants.all" "$BUILD_GRADLE"; then
            echo "build.gradle 已包含 applicationVariants 配置，更新版本号"
            # 更新现有配置中的版本号，确保包含 .apk 扩展名
            # 匹配带或不带 .apk 的旧配置，统一替换为带 .apk 的新配置
            sed -i "s/def apkName = \"Pixuli_[^\"]*\"/def apkName = \"Pixuli_${VERSION}.apk\"/" "$BUILD_GRADLE"
          else
            echo "添加 applicationVariants 配置到 build.gradle"
            # 使用 printf 构建配置内容，避免 heredoc 的 YAML 缩进问题
            printf '\n// 配置 APK 输出文件名\n' >> "$BUILD_GRADLE"
            printf 'android.applicationVariants.all { variant ->\n' >> "$BUILD_GRADLE"
            printf '    variant.outputs.all { output ->\n' >> "$BUILD_GRADLE"
            printf '        def apkName = "Pixuli_%s.apk"\n' "$VERSION" >> "$BUILD_GRADLE"
            printf '        outputFileName = apkName\n' >> "$BUILD_GRADLE"
            printf '    }\n' >> "$BUILD_GRADLE"
            printf '}\n' >> "$BUILD_GRADLE"
          fi
          echo "APK 输出文件名已配置为: Pixuli_${VERSION}.apk"
        working-directory: apps/mobile

      - name: Cache Gradle build cache
        uses: actions/cache@v4
        with:
          path: apps/mobile/android/.gradle
          key: ${{ runner.os }}-gradle-build-${{ hashFiles('apps/mobile/android/**/*.gradle*') }}
          restore-keys: |
            ${{ runner.os }}-gradle-build-
      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew
        working-directory: apps/mobile

      - name: Configure Gradle properties
        run: |
          # 在 prebuild 后配置 gradle.properties 以优化构建
          if [ -f "android/gradle.properties" ]; then
            echo "" >> android/gradle.properties
            echo "# CI 构建优化配置" >> android/gradle.properties
            echo "org.gradle.jvmargs=-Xmx4096m -XX:MaxMetaspaceSize=1024m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8" >> android/gradle.properties
            echo "org.gradle.caching=true" >> android/gradle.properties
            echo "org.gradle.vfs.watch=true" >> android/gradle.properties
            echo "org.gradle.workers.max=4" >> android/gradle.properties
            echo "android.enableMinifyInReleaseBuilds=true" >> android/gradle.properties
            echo "android.enableShrinkResourcesInReleaseBuilds=true" >> android/gradle.properties
          fi
        working-directory: apps/mobile

      - name: Build Android (APK)
        id: build
        env:
          ORG_GRADLE_PROJECT_android.enableMinifyInReleaseBuilds: 'true'
          ORG_GRADLE_PROJECT_android.enableShrinkResourcesInReleaseBuilds: 'true'
        run: |
          cd android
          ./gradlew assembleRelease \
            --no-daemon \
            --parallel \
            --build-cache \
            --max-workers=4 \
            --warning-mode=none
          echo "构建完成，退出码: $?"
        working-directory: apps/mobile

      - name: Locate artifacts
        id: afp
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          EXPECTED_APK_NAME="Pixuli_${VERSION}.apk"
          echo "=== 查找 APK 文件 ==="
          echo "当前工作目录: $(pwd)"
          # 检查 android 目录是否存在
          if [ ! -d "android" ]; then
            echo "错误: android 目录不存在"
            echo "当前目录内容:"
            ls -la
            exit 1
          fi
          # 使用相对于 apps/mobile 的路径
          APK_DIR="android/app/build/outputs/apk/release"
          echo "查找目录: $APK_DIR"
          # 检查构建输出目录结构
          echo "=== 检查构建输出目录结构 ==="
          if [ -d "android/app/build" ]; then
            echo "android/app/build 目录存在"
            find android/app/build -type d -name "outputs" 2>/dev/null | head -5 || echo "未找到 outputs 目录"
          else
            echo "android/app/build 目录不存在"
          fi
          if [ -d "android/app/build/outputs" ]; then
            echo "android/app/build/outputs 目录存在"
            ls -la android/app/build/outputs/ || echo "无法列出 outputs 目录"
          fi
          if [ ! -d "$APK_DIR" ]; then
            echo "错误: APK 目录不存在: $APK_DIR"
            echo "搜索所有可能的 APK 位置:"
            find android -name "*.apk" -type f 2>/dev/null || echo "未找到任何 APK 文件"
            exit 1
          fi
          echo "APK 目录内容:"
          ls -la "$APK_DIR" || echo "目录为空"
          # 查找 APK 文件（相对于当前目录 apps/mobile）
          # 首先尝试查找带 .apk 扩展名的文件
          APK_FILE=$(find "$APK_DIR" -name "*.apk" -type f | head -n1)
          # 如果没有找到，尝试查找不带扩展名的文件（可能是配置问题导致的）
          if [ -z "$APK_FILE" ]; then
            echo "未找到 .apk 文件，尝试查找不带扩展名的文件..."
            EXPECTED_NAME="Pixuli_${VERSION}"
            if [ -f "$APK_DIR/$EXPECTED_NAME" ]; then
              APK_FILE="$APK_DIR/$EXPECTED_NAME"
              echo "找到不带扩展名的文件: $APK_FILE"
              # 重命名为带 .apk 扩展名的文件
              mv "$APK_FILE" "$APK_DIR/${EXPECTED_NAME}.apk"
              APK_FILE="$APK_DIR/${EXPECTED_NAME}.apk"
              echo "已重命名为: $APK_FILE"
            else
              # 查找任何可能的 APK 文件（按大小判断，通常 APK 文件较大）
              APK_FILE=$(find "$APK_DIR" -type f -size +1M ! -name "*.json" ! -name "*.txt" | head -n1)
              if [ -n "$APK_FILE" ]; then
                echo "找到可能的 APK 文件（按大小）: $APK_FILE"
                # 如果文件名不包含 .apk，添加扩展名
                if [[ "$APK_FILE" != *.apk ]]; then
                  mv "$APK_FILE" "${APK_FILE}.apk"
                  APK_FILE="${APK_FILE}.apk"
                  echo "已添加 .apk 扩展名: $APK_FILE"
                fi
              fi
            fi
          fi
          if [ -z "$APK_FILE" ]; then
            echo "错误: 未找到 APK 文件"
            echo "搜索所有可能的 APK 位置:"
            find android -name "*.apk" -type f 2>/dev/null || echo "未找到任何 APK 文件"
            find android/app/build/outputs/apk -type f -size +1M 2>/dev/null || echo "未找到任何大文件"
            exit 1
          fi
          echo "找到 APK 文件: $APK_FILE"
          echo "文件大小: $(du -h "$APK_FILE" | cut -f1)"
          # 确保路径是相对于 apps/mobile 的（去掉开头的 ./ 如果有）
          APK_FILE="${APK_FILE#./}"
          # 转换为相对于项目根目录的路径
          APK_RELATIVE_PATH="apps/mobile/$APK_FILE"
          echo "相对路径: $APK_RELATIVE_PATH"
          echo "验证路径是否存在:"
          if [ -f "$APK_RELATIVE_PATH" ]; then
            echo "✓ 文件存在: $APK_RELATIVE_PATH"
          else
            echo "✗ 文件不存在: $APK_RELATIVE_PATH"
            echo "尝试使用绝对路径:"
            ABSOLUTE_PATH="$(pwd)/$APK_FILE"
            echo "绝对路径: $ABSOLUTE_PATH"
            if [ -f "$ABSOLUTE_PATH" ]; then
              echo "✓ 绝对路径文件存在"
              PROJECT_ROOT="${GITHUB_WORKSPACE:-/home/runner/work/Pixuli/Pixuli}"
              APK_RELATIVE_PATH="${ABSOLUTE_PATH#$PROJECT_ROOT/}"
              echo "计算后的相对路径: $APK_RELATIVE_PATH"
            fi
          fi
          echo "apk=$APK_RELATIVE_PATH" >> $GITHUB_OUTPUT
          echo "apk_name=$EXPECTED_APK_NAME" >> $GITHUB_OUTPUT
        working-directory: apps/mobile

      - name: Upload Android artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-apk
          path: ${{ steps.afp.outputs.apk }}
          if-no-files-found: error

      - name: Attach to GitHub Release
        if: needs.detect.outputs.release_enabled == 'true' && (needs.detect.outputs.is_tag == 'true' || github.event_name == 'workflow_dispatch')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.afp.outputs.apk }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  ios:
    name: iOS build (EAS)
    needs: detect
    if: needs.detect.outputs.do_ios == 'true'
    runs-on: macos-14
    defaults:
      run:
        working-directory: apps/mobile
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies (workspace)
        run: pnpm install --frozen-lockfile
        working-directory: .

      - name: Install EAS CLI
        run: pnpm dlx eas-cli@latest --version

      - name: EAS build (iOS)
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
        run: |
          pnpm dlx eas-cli build --platform ios --non-interactive --no-wait
          # 由于 EAS 云端构建，此处仅输出提交信息与链接
      - name: Upload EAS build info
        if: always()
        run: |
          echo "EAS iOS 构建已触发，登录 Expo 查看进度与产物下载。" > eas-ios-info.txt
      - name: Upload iOS build info artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-eas-info
          path: eas-ios-info.txt

      - name: Attach info to GitHub Release
        if: needs.detect.outputs.release_enabled == 'true' && (needs.detect.outputs.is_tag == 'true' || github.event_name == 'workflow_dispatch')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            eas-ios-info.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
